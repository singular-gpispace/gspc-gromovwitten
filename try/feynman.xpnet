<defun name="feynman_deg">

  <in name="degree" type="int" place="degree"/>
  <in name="N" type="int" place="N"/>
  <in name="graph" type="string" place="graph"/>
  <out name="fey_out" type="int" place="fey_out"/>

  <net>
    <place name="degree" type="int"/>
    <place name="N" type="int"/>
  <place name="fey_out" type="int" />

    <transition name="partition">
      <defun>
        <in name="d" type="int"/>
        <in name="n" type="int"/>
        <out name="v" type="list"/> 

        <module name="feynman" function=" sum_deg (n,d,v)">
          <cinclude href="iostream"/>
          <cinclude href="vector"/>
          <cinclude href="sstream"/>
          <code><![CDATA[


    for (int e = 0; e < d; e++) {
        std::vector<int> x(n, 0);
        x[0] = d - e;
        x[n - 1] = e;
        v.push_back(x);
    }

          ]]></code>
        </module>
      </defun>
      <connect-in port="n" place="N"/>
      <connect-in port="d" place="degree"/>
      <connect-out-many port="v" place="d_vectors"/>
    </transition>

    <place name="d_vectors" type="list"/>

<transition name="Combination">
      <defun>
        <in name="v" type="list"/>
        <in name="a" type="list"/>
        <in name="y" type="list"/>

        <out name="vec" type="list"/>
        <module name="feynman" function=" partition(v, vec,a,y)">
          <cinclude href="iostream"/>
          <cinclude href="vector"/>
          <cinclude href="numeric"/>
          <cinclude href="sstream"/>

          <code><![CDATA[
                        
   
    std::vector<std::vector<std::vector<int>> > ge;
        int k=v.size();
        if (k == 0) {
            throw std::invalid_argument("k should be nonzero");
        }
        int d = std::accumulate(v.begin(), v.end(), 0);
auto it_a = v.begin();
if (!v.empty() && *boost::get<int>(&*it_a++) == d) {
    vec.push_back(v);
}
int n = 1;
int nn = d + k - 1;
int k1 = d;
for (int i = 1; i <= k1; ++i) {
    n *= (nn - i + 1);
    n /= i;
}
int e = d - boost::get<int>(*v.begin());

using MyList = std::list<boost::variant<
    boost::detail::variant::recursive_flag<we::type::literal::control>,
    bool, int, long int, unsigned int, long unsigned int, float, double, char,
    std::string, bitsetofint::type, we::type::bytearray,
    std::list<boost::recursive_variant_, std::allocator<boost::recursive_variant_>>,
    std::set<boost::recursive_variant_, std::less<boost::recursive_variant_>, std::allocator<boost::recursive_variant_>>,
    std::map<boost::recursive_variant_, boost::recursive_variant_, std::less<boost::recursive_variant_>, std::allocator<std::pair<const boost::recursive_variant_, boost::recursive_variant_>>>,
    std::list<std::pair<std::string, boost::recursive_variant_>, std::allocator<std::pair<std::string, boost::recursive_variant_>>>>
>;MyList yy(k, 0);

// Update the first element of the list
auto it = yy.begin();
*it = boost::get<int>(*v.begin()) - 1;

// Update the last element of the list
std::advance(it, k - 1);
*it = e + 1;
// Push back the updated elements into yy
yy.push_back(*it);
// Note: Ensure you update all elements of yy as needed
auto it_v = v.begin();  // Rename it to it_v
auto it_yy = yy.begin(); // Keep this declaration

while (it_v != v.end() && it_yy != yy.end()) {
    if (*it_v != *it_yy) {
        // Your logic here
        for (auto i = v.rbegin(); i != v.rend(); ++i) {
            if (i == v.rbegin() && boost::get<int>(*i) == d) {
                // vec.push_back(v);
                break;
            } else {
                for (auto j = std::next(i); j != v.rend(); ++j) {
                    if (boost::get<int>(*j) != 0) {
                        --boost::get<int>(*j);
                        int vk = boost::get<int>(*std::next(i));
                        boost::get<int>(*std::next(i)) = 0;
                        boost::get<int>(*j) = vk + 1;
                        // vec.push_back(v);
                        break;
                    }
                }
            }
            // vec.push_back(v);
            break;
        }
        vec.push_back(v);
    } else {
        break;
    }
    ++it_v;  // Increment it_v
    ++it_yy;
}

          ]]></code>
        </module>
      </defun>
      <connect-in port="v" place="d_vectors"/>
      <connect-out-many port="vec" place="branchtype"/>
    </transition>

    <place name="branchtype" type="list"/>
    <place name="graph" type="string"/>


    <transition name="feynman_degree">
      <defun>
        <in name="a" type="list"/>
        <in name="G" type="string"/>
        <out name="s" type="int"/>

        <module name="feynman" function="s feynman_integral_degree(G,a)">
        <cinclude href="iostream"/>
        <cinclude href="vector"/>
        <cinclude href="numeric"/>
        <cinclude href="tuple"/>
        <cinclude href="algorithm"/>
        <cinclude href="unordered_map"/>
        <cinclude href="functional"/>
        <cinclude href="cmath"/>
        <cinclude href="sstream"/>
        <cinclude href="stack"/>
        <cinclude href="unordered_set"/>

        <code><![CDATA[
         // std::vector<std::vector<std::vector<int>>> aj=stringToVectorv(a);
         using Element = std::pair<std::pair<int, int>, std::pair<int, int>>;
        using Sequence = std::vector<Element>;
   
    //std::string graph= "{{1, 2}, {1, 2}, {1, 2}}";
   // std::string G = graph;
   // std::cout << "graph: " << G << std::endl;
std::string G_copy=G;
   
 // Remove double quotes at the beginning and end
    if (!G_copy.empty() && G_copy.front() == '"' && G_copy.back() == '"') {
        G_copy = G_copy.substr(1, G_copy.size() - 2);
    }

    // Vector to store parsed values
    std::vector<std::vector<int>> Gvec;

    // Loop to parse the string
    std::vector<int> innerVec;
    std::string numString;
    bool inBraces = false; // Flag to track if currently parsing inside braces
    for (char ch : G_copy) {
        if (isdigit(ch)) {
            numString += ch;
        } else if (ch == ',' || ch == ' ') {
            if (!numString.empty()) {
                innerVec.push_back(std::stoi(numString));
                numString.clear();
            }
        } else if (ch == '{') {
            inBraces = true;
        } else if (ch == '}') {
            if (!numString.empty()) {
                innerVec.push_back(std::stoi(numString));
                numString.clear();
            }
            if (!innerVec.empty()) {
                Gvec.push_back(innerVec);
                innerVec.clear();
            }
            inBraces = false;
        }
        // Check if we are outside the braces and encountered a comma or space
        if (!inBraces && (ch == ',' || ch == ' ')) {
            // Reset the inner vector if outside braces
            innerVec.clear();
        }
    }

    // Construct vector of pairs
    std::vector<std::pair<int, int>> Gv;
    for (const auto& vec : Gvec) {
        if (vec.size() >= 2) {
            Gv.emplace_back(vec[0], vec[1]);
        }
    }

    // Output the vector of pairs
   /* std::cout << "Vector of pairs:" << std::endl;
    for (const auto& pair : Gv) {
        std::cout << "{" << pair.first << ", " << pair.second << "} ";
    }
    std::cout << std::endl;
   */

    std::unordered_set<int> nbv;
       //  std::vector<int> fey;
          for (const auto& e : Gv) {
        nbv.insert(e.first);
        nbv.insert(e.second);
    }
        std::vector<int> fey_d;

    int nv = nbv.size(); //nb vertices.
    //std::cout<<" nv = "<<nv<<std::endl;



    int N = std::accumulate(a.begin(), a.end(), 0);
    // std::vector<std::tuple<int, std::vector<int>>> f = signature_and_multiplicitie(Gv, a);
    std::vector<int> p;
    std::vector<std::tuple<int, std::vector<int>>> b;

    std::vector<int> l(nv, 0);

    auto it_a = a.begin();
for (const auto& ev : Gv) {
    // Check if the variant is an integer and extract its value
    int ai = 0; // Default value if not an integer
    if (const int* intValue = boost::get<int>(&*it_a++)) {
        ai = *intValue;
    }

    if (ai == 0 && ev.first != ev.second) {
        l[ev.first - 1] = 1;
        l[ev.second - 1] = 1;
    }
}



        for (size_t i = 0; i < l.size(); i++) {
            int li = l[i];
            if (li == 1) {
                p.push_back(i + 1);
            }
        }

        std::sort(p.begin(), p.end());

        std::vector<std::vector<int>> per;
        do {
            per.push_back(p);
        } while (std::next_permutation(p.begin(), p.end()));
        int fact = 1;
        for(int i = 1; i <= nv; i++) {
            fact *= i;
        }
        for (const auto& ga : per) {
            std::vector<int> flip(a.size(), 0);
            for (std::list<int>::iterator it = a.begin(); it != a.end(); ++it) {
                int ai=*it;
                std::pair<int, int> ev = Gv[i];

                if (ai == 0 && ev.first != ev.second) {
                int ii = -1;
                int ij = -1;
                for (size_t j = 0; j < ga.size(); ++j) {
                    if (ga[j] == ev.first) {
                        ii = j;
                    }
                    if (ga[j] == ev.second) {
                        ij = j;
                    }
                }

                if (ii != -1 && ij != -1) {
                    if (ii < ij) {
                        flip[i] = -1;
                    } else {
                        flip[i] = 0;
                    }
                }
                } else if (ev.first == ev.second) {
                    flip[i] = -2;
                } else if (ai != 0 && ev.first != ev.second) {
                    flip[i] = ai;
                }
            }

            std::vector<int> tmp=    flip;

            bool comp = false;
            int j = 0;
            while (!comp && j < b.size()) {
                int tt=1;
                std::vector<int> bb=std::get<1>(b[j]);
                if (tmp.size() != bb.size()) 
                tt=0;
                for (std::size_t i = 0; i < tmp.size(); ++i) {
                    if (tmp[i] != bb[i])
                    tt=0;
                }
                if (tt) { // Accessing the second element of the tuple
                    comp = true;
                    std::get<0>(b[j]) += 1;
                }
                else {
                    j++;
                }
            }
            if (!comp) {
                b.push_back(std::make_tuple(1, tmp));
            }
        }
        std::vector<std::tuple<int, std::vector<int>>> f;

        for (auto& tuple : b) {
        int& element = std::get<0>(tuple); 
        // std::cout<<" element "<<element<<std::endl;
        element *= fact / per.size();
        }
        if (b.size() == 1) {
        f= b;
        } 
        else {
        std::vector<std::tuple<int, std::vector<int>>> group;

        for (const auto& pair1 : b) {
        int n = std::get<0>(pair1);
        std::vector<int> values1 = std::get<1>(pair1);

        int mm = 2 * n;
        auto it1 = std::find(group.begin(), group.end(), pair1);
        auto it2 = std::find(group.begin(), group.end(), std::make_tuple(mm, values1));

        if (it1 != group.end() || it2 != group.end()) {
        continue;
        }

        bool equiv = false;

        for (const auto& pair2 : b) {
        int m = std::get<0>(pair2);
        std::vector<int> values2 = std::get<1>(pair2);
        int mm = 2 * n;
        auto it1 = std::find(group.begin(), group.end(), pair2);
        auto it2 = std::find(group.begin(), group.end(), std::make_tuple(2 * m, values2));

        if (it1 != group.end() || it2 != group.end()) {
        continue;
        }
        std::vector<int> result_arr;
        for (int x : values2) {
        result_arr.push_back(x == -1 ? 0 : (x == 0 ? -1 : x));
        }

        if (n == m && values1 == result_arr) {

        equiv = true;
        break;
        }
        }
        // std::cout <<" equiv = " <<equiv << std::endl;

        if (equiv) {
        group.push_back(std::make_tuple(mm, values1));
        }
        }
        f=group;
        }



        int myfey;
        std::vector<int> fey;

        for (const auto& item : f) {
        int factor = std::get<0>(item);
        const auto& multiplicities = std::get<1>(item);
        std::vector<Sequence> tmp;
        for (size_t j = 0; j < a.size(); j++) {
        const auto& multiplicity = multiplicities[j]; 
        if (multiplicity == -1) {
        Sequence  v;

        for (int i = 1; i <= N; ++i) {
        if (Gv[j].second < Gv[j].first)
        v.push_back(std::make_pair(std::make_pair(Gv[j].second, -i), std::make_pair(Gv[j].first, +i)));
        else
        v.push_back(std::make_pair(std::make_pair(Gv[j].first, +i), std::make_pair(Gv[j].second, -i)));
        }
        tmp.push_back(v);

        } else if (multiplicity == 0) {
        Sequence  vv;
        for (int i = 1; i <= N; ++i) {
        if (Gv[j].first < Gv[j].second)
        vv.push_back(std::make_pair(std::make_pair(Gv[j].first, -i), std::make_pair(Gv[j].second, +i)));
        else
        vv.push_back(std::make_pair(std::make_pair(Gv[j].second, +i), std::make_pair(Gv[j].first, -i)));
        }
        tmp.push_back(vv);

        } else {

        Sequence  x_powers;


        for (int w = 1; w <= multiplicity; ++w) {
        if (multiplicity % w == 0) {
        x_powers.push_back(std::make_pair(std::make_pair(Gv[j].first, +w), std::make_pair(Gv[j].second, -w)));
        x_powers.push_back(std::make_pair(std::make_pair(Gv[j].first, -w), std::make_pair(Gv[j].second, +w)));
        }
        }
        tmp.push_back(x_powers);
        }
        }
        //   std::vector<Sequence> tt = mergetuple(tmp);
        std::vector<Sequence> res;
        int N = 0;
        for (const auto& subvec : tmp) {
        for (const auto& elem : subvec) {
        N = std::max({N, elem.first.first, elem.second.first});
        }
        }
        std::vector<int> v(N + 1, 0);
        std::vector<Sequence> cartesian_product;
        Sequence stack;

        std::stack<std::pair<Sequence, int>> stackIndex;
        if (!tmp.empty())
        stackIndex.push(std::make_pair(stack, tmp.size() - 1));

        while (!stackIndex.empty()) {
        // Retrieve the top pair from stackIndex
        std::pair<Sequence, int> topPair = stackIndex.top();
        stackIndex.pop();

        // Extract curStack and curIndex from the top pair
        Sequence curStack = topPair.first;
        int curIndex = topPair.second;

        // Retrieve the current sequence from tmp
        Sequence sequence = tmp[curIndex];

        // Iterate over elements of the current sequence
        for (const auto& tuple : sequence) {
        // Add tuple to curStack
        curStack.push_back(tuple);

        if (curIndex == 0) {
        // If at the last sequence, add curStack to cartesian_product
        cartesian_product.push_back(curStack);
        } else {
        // Push curStack and curIndex - 1 to stackIndex
        stackIndex.push(std::make_pair(curStack, curIndex - 1));
        }

        // Remove the last tuple from curStack
        curStack.pop_back();
        }
        }



        for (const auto& u : cartesian_product) {
        bool allZero = true;
        for (const auto& pp : u) {
        v[pp.first.first] += pp.first.second;
        v[pp.second.first] += pp.second.second;
        }
        for (int val : v) {
        if (val != 0) {
        allZero = false;
        break;
        }
        }
        if (allZero) {
        res.push_back(u);
        }
        std::fill(v.begin(), v.end(), 0);
        }
        //int ty = sum_absolute_products(res);
        int ty = 0;
        for (auto &t : res) {
        int abs_product = 1.0;
        for (auto &ui : t) {
        abs_product *= abs(ui.first.second );
        }
        ty += abs_product;
        }
        fey.push_back(factor * ty);
        }
        myfey= std::accumulate(fey.begin(), fey.end(), 0.0);
        //std::cout<<"myfey "<< myfey<<std::endl;

        fey_d.push_back(myfey);
    
          int su=0;
          for (int s:fey_d  ){
            su+=s;
          }
          std::cout<< su;
          return su;

        ]]></code>
        </module>
      </defun>
      <connect-in port="G" place="graph"/>
      <connect-in port="a" place="branchtype"/>
      <connect-out port="s" place="fey_out"/>

    </transition>
   
  </net>

</defun>
