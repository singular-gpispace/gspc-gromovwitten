<defun name="feynman_deg">

  <in name="degree" type="int" place="degree"/>
  <in name="N" type="int" place="N"/>
  <out name="my_vectors" type="list" place="my_vectors"/>

  <net>
    <place name="degree" type="int"/>
    <place name="N" type="int"/>

    <transition name="partition">
      <defun>
        <in name="d" type="int"/>
        <in name="n" type="int"/>
        <out name="v" type="list"/>

        <module name="feynman_module" function=" init_vector(n,d,v)">
          <cinclude href="iostream"/>
          <cinclude href="vector"/>
          <cinclude href="sstream"/>
          <cinclude href="feynman.hpp"/>
          <code><![CDATA[
            std::vector<int> x(n, 0);
              x.front() = d ;
              using pnet_value = pnet::type::value::value_type;
              for (int xi : x)
              {
                  v.push_back(pnet_value(xi));
              }
              ]]>
          </code>
        </module>
      </defun>
      <connect-in port="n" place="N"/>
      <connect-in port="d" place="degree"/>
      <connect-out port="v" place="d_vectors"/>
    </transition>

    <place name="d_vectors" type="list"/>
    <place name="my_vectors" type="list"/>

    <transition name="Combination">
      <defun>
        <in name="v" type="list"/>
        <in name="v_copy" type="list"/>
        <out name="vec" type="list"/>
        <out name="vec_copy" type="list"/>

        <module name="feynman_module" function=" part(v,v_copy, vec,vec_copy)">
          <cinclude href="iostream"/>
          <cinclude href="vector"/>
          <cinclude href="numeric"/>
          <cinclude href="sstream"/>
          <cinclude href="../include/feynman/feynman.hpp"/>

          <code><![CDATA[
            using pnet_value = pnet::type::value::value_type;
            using pnet_list = std::list<pnet_value>;
            int m=4;
            std::vector<int> x;
              std::cout << " x is " << " ";
          
              for (const auto& elem : v) {
                  auto ptr = boost::get<int>(&elem);
                  x.push_back(*ptr);
                  std::cout << *ptr << " ";
              }
          
              for (int i = 1; i <= m; ++i) {
                  x = next_partition(x);
                  if (i == m) {
                      std::cout << "myx is ";
                      for (int xi : x) {
                          vec_copy.push_back(pnet_value(xi));
                          std::cout << xi << " ";
                      }
          
                      std::cout << std::endl; // To move to the next line after printing
                  }
          
                  pnet_list temp_a;
                  for (int xi : x) {
                      vec.push_back(pnet_value(xi)); // Simplified casting
                  }
          
                  std::cout << std::endl; // To move to the next line after printing
                  std::cout << " here " << std::endl;
          
                  for (const auto& elem : vec) {
                      auto ptr = boost::get<int>(&elem);
                      std::cout << *ptr << " ";
                  }
                  std::cout << std::endl;
          
              }
          ]]>
          </code>
        </module>
      </defun>
      <connect-in port="v" place="d_vectors"/>
      <connect-in port="v_copy" place="my_vectors"/>
      <connect-out-many port="vec" place="branchtype"/>
      <connect-out port="vec_copy" place="my_vectors"/>

    </transition>
    <place name="branchtype" type="list"/>

  </net>

</defun>