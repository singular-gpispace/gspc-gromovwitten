<defun name="feynman_deg">

  <in name="degree" type="int" place="degree"/>
  <in name="N" type="int" place="N"/>
  <in name="graph" type="string" place="graph"/>
  <out name="L" type="unsigned long" place="L"/> 

  <net>
    <place name="degree" type="int"/>
    <place name="N" type="int"/>
  <place name="fey_out" type="unsigned long" />

    <transition name="partition">
      <defun>
        <in name="d" type="int"/>
        <in name="n" type="int"/>
        <out name="v" type="list"/> 

        <module name="feynman_module" function=" sum_deg (n,d,v)">
          <cinclude href="iostream"/>
          <cinclude href="vector"/>
          <cinclude href="sstream"/>
          <code><![CDATA[


   for (int e = 0; e < d; e++) {
        std::list<int> x(n, 0);
        x.front() = d - e;
        x.back() = e;

        std::list<pnet::type::value::value_type> temp;
        for (int xi : x) {
            temp.push_back(pnet::type::value::value_type(xi));
        }
        v.push_back(temp);
    }

         ]]></code>
        </module>
      </defun>
      <connect-in port="n" place="N"/>
      <connect-in port="d" place="degree"/>
      <connect-out-many port="v" place="d_vectors"/>
    </transition>

    <place name="d_vectors" type="list"/>

<transition name="Combination">
      <defun>
        <in name="v" type="list"/>
        <out name="vec" type="list"/>

        <module name="feynman_module" function=" partition(v, vec)">
          <cinclude href="iostream"/>
          <cinclude href="vector"/>
          <cinclude href="numeric"/>
          <cinclude href="sstream"/>
         <cinclude href="../include/feynman/feynman.hpp"/>

          <code><![CDATA[
          std::vector<int> x;
          for (const auto& elem : v) {
            auto ptr = boost::get<int>(&elem) ;
              x.push_back(*ptr);
            
          }
      
    vector2d gen=iterate( x);
      using pnet_value = pnet::type::value::value_type;
    using pnet_list = std::list<pnet_value>;
        for (std::vector<int> &a : gen)
    {
        pnet_list temp_a;
        for (int xi : a)
        {
            temp_a.push_back(pnet::type::value::value_type(xi));
        }
        vec.push_back(temp_a);
    }

          ]]></code>
        </module>
      </defun>
      <connect-in port="v" place="d_vectors"/>
      <connect-out-many port="vec" place="branchtype"/>
    </transition>



<transition name="signature">
  <defun>
    <in name="a" type="list"/>
    <in name="G" type="string"/>
    <out name="s" type="list"/>
    <module name="feynman_module" function=" signature_and_multiplicities(G, a,s)">
      <cinclude href="iostream"/>
      <cinclude href="vector"/>
      <cinclude href="numeric"/>
      <cinclude href="sstream"/>
            <cinclude href="algorithm"/>
      <cinclude href="tuple"/>
         <cinclude href="feynman.hpp"/>


      <code><![CDATA[
        std::string G_copy=G;
        // Remove double quotes at the beginning and end
        if (!G_copy.empty() && G_copy.front() == '"' && G_copy.back() == '"') {
          G_copy = G_copy.substr(1, G_copy.size() - 2);
        }
        // Vector to store parsed values
        std::vector<std::vector<int>> Gvec;
        // Loop to parse the string
        std::vector<int> innerVec;
        std::string numString;
        bool inBraces = false;
        // Flag to track if currently parsing inside braces
        for (char ch : G_copy) {
          if (isdigit(ch)) {
            numString += ch;
          } else if (ch == ',' || ch == ' ') {
            if (!numString.empty()) {
              innerVec.push_back(std::stoi(numString));
              numString.clear();
            }
          } else if (ch == '{') {
            inBraces = true;
          } else if (ch == '}') {
            if (!numString.empty()) {
              innerVec.push_back(std::stoi(numString));
              numString.clear();
            }
            if (!innerVec.empty()) {
              Gvec.push_back(innerVec);
              innerVec.clear();
            }
            inBraces = false;
          }
          // Check if we are outside the braces and encountered a comma or space
          if (!inBraces && (ch == ',' || ch == ' ')) {
            // Reset the inner vector if outside braces
            innerVec.clear();
          }
        }
        // Construct vector of pairs
        std::vector<std::pair<int, int>> Gv;
        for (const auto& vec : Gvec) {
          if (vec.size() >= 2) {
            Gv.emplace_back(vec[0], vec[1]);
          }
        }

            std::vector<int> av;
        for (const auto& elem : a) {
          if (auto ptr = boost::get<int>(&elem)) {
            av.push_back(*ptr);
          }
        }

    std::vector<std::tuple<int, std::vector<int>>> f= signature_and_multiplicitie( Gv,   av);
    using pnet_value = pnet::type::value::value_type;
    using pnet_list = std::list<pnet_value>;
    for (const auto& tuple : f) {
        int index = std::get<0>(tuple);
        const auto& fiVector = std::get<1>(tuple); // Get the vector<int> fi
        pnet_list fiList;
        for (int value : fiVector) {
            fiList.push_back(value);
        }
        std::string str;
        for (auto it = fiList.begin(); it != fiList.end(); ++it) {
            if (it != fiList.begin()) {
                str += ", ";
            }
            int listValue = boost::get<int>(*it);
            str += std::to_string(listValue);
        }
        std::string fiString = std::to_string(index) + ", " + str;
        s.push_back(fiString);
    }
    ]]></code>
    </module>
  </defun>
    <connect-read port="G" place="graph"/>
    <connect-in port="a" place="branchtype"/>
    <connect-out-many port="s" place="sign"/>
</transition>
  <place name="sign" type="string" />

    <place name="branchtype" type="list"/>
    <place name="graph" type="string"/>



    <transition name="feynman_degree">
      <defun>
        <in name="a" type="string"/>
        <in name="G" type="string"/>
        <out name="s" type="unsigned long"/>

        <module name="feynman_module" function="s feynman_integral_degree(G,a)">
        <cinclude href="iostream"/>
        <cinclude href="vector"/>
        <cinclude href="numeric"/>
        <cinclude href="tuple"/>
        <cinclude href="algorithm"/>
        <cinclude href="unordered_map"/>
        <cinclude href="functional"/>
        <cinclude href="cmath"/>
        <cinclude href="sstream"/>
        <cinclude href="stack"/>
        <cinclude href="unordered_set"/>
         <cinclude href="feynman.hpp"/>
        <code><![CDATA[
std::string G_copy=G;
// Remove double quotes at the beginning and end
if (!G_copy.empty() && G_copy.front() == '"' && G_copy.back() == '"') {
	G_copy = G_copy.substr(1, G_copy.size() - 2);
}
// Vector to store parsed values
std::vector<std::vector<int>> Gvec;
// Loop to parse the string
std::vector<int> innerVec;
std::string numString;
bool inBraces = false;
// Flag to track if currently parsing inside braces
for (char ch : G_copy) {
	if (isdigit(ch)) {
		numString += ch;
	} else if (ch == ',' || ch == ' ') {
		if (!numString.empty()) {
			innerVec.push_back(std::stoi(numString));
			numString.clear();
		}
	} else if (ch == '{') {
		inBraces = true;
	} else if (ch == '}') {
		if (!numString.empty()) {
			innerVec.push_back(std::stoi(numString));
			numString.clear();
		}
		if (!innerVec.empty()) {
			Gvec.push_back(innerVec);
			innerVec.clear();
		}
		inBraces = false;
	}
	// Check if we are outside the braces and encountered a comma or space
	if (!inBraces && (ch == ',' || ch == ' ')) {
		// Reset the inner vector if outside braces
		innerVec.clear();
	}
}
// Construct vector of pairs
std::vector<std::pair<int, int>> Gv;
for (const auto& vec : Gvec) {
	if (vec.size() >= 2) {
		Gv.emplace_back(vec[0], vec[1]);
	}
}
 std::istringstream iss(a);

// Read the factor from the string
int factor;
char comma;
iss >> factor >> comma;

// Read the vector of integers from the string
std::vector<int> av;
int value;
while (iss >> value) {
    av.push_back(value); // Read each integer and push it into the vector
    iss >> comma; // Read the comma after each integer
}
unsigned long fe= feynman_integral_type( Gv,  std::make_tuple(factor, std::vector<int>{}), av);
return fe;

      ]]></code>
      </module>
      </defun>
      <connect-read port="G" place="graph"/>
      <connect-in port="a" place="sign"/>
      <connect-out port="s" place="fey_out"/>
    </transition>
   
    <transition name="RHS">
      <defun>
        <inout name="a" type="unsigned long"/>
        <inout name="s" type="control"/>
        <module name="feynman_module" function="plus()">
        <code><![CDATA[
        ]]></code>
        </module>
      </defun>
      <connect-in port="a" place="fey_out"/>
      <connect-in port="s" place="right_init"/>
      <connect-out port="s" place="left_init"/>
      <connect-out port="a" place="R"/>

    </transition>
<place name="left_init" type="control">
  <token><value>[]</value></token>
</place>
<place name="right_init" type="control"/>

    <transition name="LHS">
      <defun>
        <inout name="a" type="unsigned long"/>
        <inout name="s" type="control"/>

        <module name="feynman_module" function="count()">
        <code><![CDATA[
          
        ]]></code>
        </module>
      </defun>
      <connect-in port="s" place="left_init"/>
      <connect-out port="s" place="right_init"/>
      <connect-in port="a" place="fey_out"/>
      <connect-out port="a" place="L"/>
    </transition>


<place name="L" type="unsigned long"/>
<place name="R" type="unsigned long"/>

    <transition name="Reduce">
      <defun>
        <out name="s" type="unsigned long"/>
        <in name="l" type="unsigned long"/>
        <in name="r" type="unsigned long"/>
        <module name="feynman_module" function=" s add(s,l,r)">
        <code><![CDATA[
        unsigned long su = l + r;
        return su;
        ]]></code>
        </module>
      </defun>
      <connect-in port="l" place="L"/>
      <connect-in port="r" place="R"/>
      <connect-out port="s" place="fey_out"/>
    </transition>
  </net>

</defun>