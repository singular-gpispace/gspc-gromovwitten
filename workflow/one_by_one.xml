<defun name="feynman">

  <in name="degree" type="int" place="degree"/>
  <in name="edge" type="int" place="edge"/>

  <net>
    <place name="degree" type="int"/>
    <place name="edge" type="int"/>

    <transition name="partition">
      <defun>
        <in name="d" type="int"/>
        <in name="n" type="int"/>
        <out name="v" type="string"/> 

        <module name="Sum_degree" function="v sum_degree (n,d)">
          <cinclude href="iostream"/>
          <cinclude href="vector"/>
          <code><![CDATA[
            std::vector<std::vector<int>> ru;
            for(int e=0; e<d; e++){
            std::vector<int> x(n,0);
            x[0]=d-e; 
            x[n-1]=e;
            ru.push_back(x);
            }
            return ru;

          ]]></code>
        </module>
      </defun>
      <connect-in port="n" place="edge"/>
      <connect-in port="d" place="degree"/>
      <connect-out port="v" place="d_vectors"/>
    </transition>

    <place name="d_vectors" type="string"/>


<transition name="Combination">
      <defun>
        <in name="v" type="string"/>
        <out name="vec" type="string"/>
        <module name="Combination" function="vec next_partition(v)">
          <cinclude href="iostream"/>
          <cinclude href="vector"/>
          <cinclude href="numeric"/>

          <code><![CDATA[
              int k=x.size();
  
              if (k == 0) {
                  throw std::invalid_argument("k should be nonzero");
              }
              std::vector<std::vector<int> > ru;
              int d= std::accumulate(x.begin(),x.end(),0);
              std::vector<int> v(k , 0);
              v[0] = d;

              if (v==x){
              ru.push_back(v);
              }
              int n = binomial(d + k - 1, d);
              int e = d - x[0];
              std::vector<int> result = x;    
              std::vector<int> y(k, 0); 
              y[0] = x[0] - 1;
              y[k - 1] = e + 1;
              
              for (int i = 0; i < n; ++i) {
                  if (result != y) {
                      result = next_partition(result);
                      ru.push_back(result);
                  } else {
                      break;
                  }
              }
              return ru;
          ]]></code>
        </module>
      </defun>
      <connect-in port="v" place="d_vectors"/>
      <connect-out port="vec" place="branchtype"/>
    </transition>

    <place name="branchtype" type="string"/>
    <place name="graph" type="string"/>


    <transition name="feynman">
      <defun>
        <in name="a" type="string"/>
        <in name="G" type="string"/>
        <out name="s" type="int"/>

        <module name="feynman" function="s feynman_integral_degree(G,a)">
        <cinclude href="iostream"/>
        <cinclude href="vector"/>
        <cinclude href="numeric"/>
        <cinclude href="tuple"/>
        <cinclude href="algorithm"/>
        <cinclude href="unordered_map"/>
        <cinclude href="feynman.hpp"/>
        <cinclude href="functional"/>
        <cinclude href="cmath"/>

        <code><![CDATA[
          std::vector<double> fey;
          for( std::vector<int> v:a){
            fey.push_back(feynman_integral(G,v));
          }
          return fey;
          
        ]]></code>
        </module>
      </defun>
      <connect-in port="G" place="graph"/>
      <connect-in port="a" place="branchtype"/>
      <connect-out port="s" place="fey"/>

    </transition>

<place name="fey" type="int"/>

    <transition name="RHS">
      <defun>
        <inout name="a" type="int"/>
        <inout name="s" type="control"/>

        <module name="token" function="plus()">
        <code><![CDATA[
          
        ]]></code>
        </module>
      </defun>
      <connect-in port="a" place="fey"/>
      <connect-in port="s" place="right_init"/>
      <connect-out port="s" place="left_init"/>
      <connect-out port="a" place="R"/>

    </transition>

<place name="left_init" type="control"/>
<place name="right_init" type="control">
    <token><value>[]</value></token>
</place>

    <transition name="LHS">
      <defun>
        <inout name="a" type="int"/>
        <inout name="s" type="control"/>

        <module name="token" function="count()">
        <code><![CDATA[
          
        ]]></code>
        </module>
      </defun>
      <connect-in port="s" place="left_init"/>
      <connect-out port="s" place="right_init"/>
      <connect-in port="a" place="fey"/>
      <connect-out port="a" place="L"/>
    </transition>


<place name="L" type="int"/>
<place name="R" type="int"/>

    <transition name="Reduce">
      <defun>
        <out name="s" type="int"/>
        <in name="l" type="int"/>
        <in name="r" type="int"/>

        <module name="sum" function=" s add(l,r)">
        <code><![CDATA[
          int su = lhs + rhs;
          return su
        ]]></code>
        </module>
      </defun>
      <connect-in port="l" place="L"/>
      <connect-in port="r" place="R"/>
      <connect-out port="s" place="fey"/>
    </transition>
  </net>

</defun>