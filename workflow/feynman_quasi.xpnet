<defun name="feynman_deg">

  <in name="degree" type="int" place="degree"/>
  <in name="deg" type="int" place="deg"/>
  <in name="N" type="int" place="N"/>
  <in name="graph" type="list" place="graph"/>
  <in name="total" type="unsigned long" place="total"/>
  <in name="genus" type="int" place="genus"/>
  <out name="answer" type="string" place="answer"/>

  <net>
    <place name="degree" type="int"/>
    <place name="deg" type="int"/>
    <place name="N" type="int"/>
    <place name="fey_out" type="string" />
    <place name="total" type="unsigned long"/>
    <place name="genus" type="int"/>


    <transition name="degrees_fey">
      <defun>
        <in name="weightmax" type="int"/>

        <in name="d" type="int"/>
        <out name="v" type="list"/>

        <module name="feynman_module" function=" init(weightmax,d,v)">
          <cinclude href="iostream"/>
          <cinclude href="vector"/>
          <cinclude href="sstream"/>
          <cinclude href="feynman_quasi.hpp"/>

          <code><![CDATA[
          int nb = number_monomial(weightmax); // Call to your number_monomial function
        if (d < nb) {
            // Throw an exception with a proper message
            throw std::runtime_error(
                "d = " + std::to_string(d) + " should be equal to or greater than the number of monomials, which is " + std::to_string(nb));
        } else {
            // Populate the vector v with integers from 2 to d
            for (int i = 2; i <= d; ++i) {
                v.emplace_back(i);
            }
        }


         ]]>
          </code>
        </module>
      </defun>
      <connect-read port="weightmax" place="genus"/>

      <connect-in port="d" place="degree"/>
      <connect-out-many port="v" place="degrees"/>
    </transition>

    <place name="degrees" type="int"/>

    <transition name="partition">
      <defun>
        <in name="i" type="int"/>
        <in name="n" type="int"/>
        <out name="v" type="list"/>

        <module name="feynman_module" function=" gen_block_(n,i,v)">
          <cinclude href="iostream"/>
          <cinclude href="vector"/>
          <cinclude href="sstream"/>
          <cinclude href="feynman_quasi.hpp"/>
          <code><![CDATA[

          vector2d gen=gen_block(n,i);
          for (std::vector<int> ge:gen){
              std::list<pnet::type::value::value_type> temp;
              for (int xi : ge) {
                  temp.push_back(pnet::type::value::value_type(xi));
              }
              v.push_back(temp);
          }

         ]]>          </code>
        </module>
      </defun>
      <connect-read port="n" place="N"/>
      <connect-in port="i" place="degrees"/>
      <connect-out-many port="v" place="d_vectors"/>
    </transition>

    <place name="d_vectors" type="list"/>

    <transition name="Combination">
      <defun>
        <in name="v" type="list"/>
        <out name="vec" type="list"/>

        <module name="feynman_module" function=" partition(v, vec)">
          <cinclude href="iostream"/>
          <cinclude href="vector"/>
          <cinclude href="numeric"/>
          <cinclude href="sstream"/>
          <cinclude href="../include/feynman/feynman_quasi.hpp"/>

          <code><![CDATA[
          std::vector<int> x;
          for (const auto& elem : v) {
            auto ptr = boost::get<int>(&elem) ;
              x.push_back(*ptr);
            
          }
      
    vector2d gen=iterate( x);
      using pnet_value = pnet::type::value::value_type;
    using pnet_list = std::list<pnet_value>;
        for (std::vector<int> &a : gen)
    {
        pnet_list temp_a;
        for (int xi : a)
        {
            temp_a.push_back(pnet::type::value::value_type(xi));
        }
        vec.push_back(temp_a);
    }

          ]]>          </code>
        </module>
      </defun>
      <connect-in port="v" place="d_vectors"/>
      <connect-out-many port="vec" place="branchtype"/>
    </transition>


    <place name="branchtype" type="list"/>
    <place name="graph" type="list"/>

    <transition name="feynman_degree">
      <defun>
        <in name="deg" type="int"/>
        <in name="a" type="list"/>
        <in name="G" type="list"/>
        <out name="s" type="string"/>

        <module name="feynman_module" function=" feynman_integral_degree(deg,s,G,a)">
          <cinclude href="iostream"/>
          <cinclude href="vector"/>
          <cinclude href="numeric"/>
          <cinclude href="tuple"/>
          <cinclude href="algorithm"/>
          <cinclude href="unordered_map"/>
          <cinclude href="functional"/>
          <cinclude href="cmath"/>
          <cinclude href="sstream"/>
          <cinclude href="stack"/>
          <cinclude href="unordered_set"/>
          <cinclude href="feynman_quasi.hpp"/>
          <code><![CDATA[
          std::vector<int> xxx; // Define xxx outside the inner loop
            for (const auto &vii : G)
            {
                if (auto ptr = boost::get<int>(&vii))
                {                             // Check if the element is an integer
                    xxx.push_back( *ptr ); // Push the integer to the vector xx
                }
            }
          std::vector<std::pair<int, int>> Gv;
        
            // Iterate over the vector of integers, creating pairs from consecutive elements
            for (size_t i = 0; i < xxx.size(); i += 2)
            {
                Gv.push_back(std::make_pair(xxx[i], xxx[i + 1]));
            }


          std::vector<int> av;
          int c=0;
          for (const auto &xi : a)
          {
              if (auto ptr = boost::get<int>(&xi))
              {
                  av.push_back( *ptr);
                  c+=*ptr;
              }
          }

      unsigned long fe=feynman_integral_branch_type(Gv, av);
      std::vector<unsigned long> v(deg, 0); 
      v[c-1] = fe;
      s=vectorToStringULong(v);
      ]]>
          </code>
        </module>
      </defun>
      <connect-read port="deg" place="deg"/>
      <connect-read port="G" place="graph"/>
      <connect-in port="a" place="branchtype"/>
      <connect-out port="s" place="fey_out"/>
    </transition>

    <place name="sum" type="string">
      <token>
        <value>" "</value>
      </token>
    </place>

    <transition name="Reduce">
      <defun>
        <out name="ns" type="control"/>
        <in name="s" type="string"/>
        <inout name="sum" type="string"/>
        <module name="feynman_module" function="plus (ns,s, sum)">
          <cinclude href="iostream"/>
          <cinclude href="vector"/>
          <cinclude href="tuple"/>
          <cinclude href="algorithm"/>
          <cinclude href="unordered_map"/>
          <cinclude href="functional"/>
          <cinclude href="cmath"/>
          <cinclude href="sstream"/>
          <cinclude href="stack"/>
          <cinclude href="unordered_set"/>
          <cinclude href="feynman_quasi.hpp"/>
          <code><![CDATA[
            std::vector<unsigned long> v = stringToVectorUlong(sum);
                std::vector<unsigned long> w = stringToVectorUlong(s);

                // Perform the sum of the vectors
                std::vector<unsigned long> sum_vector = sumOfVectors(v, w);

                // Convert the result back to a string
                sum = vectorToStringULong(sum_vector);

          ]]>
          </code>

        </module>
      </defun>
      <connect-in port="s" place="fey_out"/>
      <connect-inout port="sum" place="sum"/>
      <connect-out port="ns" place="ns"/>
    </transition>


    <place name="ns" type="control"/>

    <place name="counter_total" type="unsigned long">
      <token>
        <value>0UL</value>
      </token>
    </place>

    <transition name="transition6">
      <defun>
        <in name="ns" type="control"/>
        <inout name="counter_total" type="unsigned long"/>
        <module name="feynman_module" function=" control1 (ns,counter_total)">
          <cinclude href="iostream"/>
          <cinclude href="vector"/>
          <cinclude href="sstream"/>
          <code><![CDATA[

          counter_total +=1;

         ]]>
          </code>
        </module>
      </defun>
      <connect-in port="ns" place="ns"/>
      <connect-inout port="counter_total" place="counter_total"/>
    </transition>


    <transition name="transition7">
      <defun>
        <in name="total" type="unsigned long"/>
        <in name="counter_total" type="unsigned long"/>
        <inout name="answer" type="string"/>

        <module name="feynman_module" function=" final (answer,total,counter_total)">
          <cinclude href="iostream"/>
          <cinclude href="vector"/>
          <cinclude href="sstream"/>
          <code><![CDATA[


         ]]>
          </code>
        </module>
      </defun>
      <condition>
      ${counter_total}:eq: ${total}
      </condition>
      <connect-read port="total" place="total"/>
      <connect-out port="answer" place="fey_sum"/>
      <connect-in port="counter_total" place="counter_total"/>
      <connect-in port="answer" place="sum"/>

    </transition>

    <place name="fey_sum" type="string" />


    <transition name="Quasimodular">
      <defun>
        <inout name="answer" type="string"/>
        <in name="weightmax" type="int"/>

        <module name="feynman_module" function=" Quasi (answer,weightmax)">
          <cinclude href="iostream"/>
          <cinclude href="vector"/>
          <cinclude href="sstream"/>
          <cinclude href="Quasi.hpp"/>
          <cinclude href="feynman_quasi.hpp"/>

          <code><![CDATA[
           std::vector<unsigned long> Iq=stringToVectorUlong(answer);


    // Maximum weight

    // Initialize FLINT polynomial context with 3 variables
    slong nv = 3;  // Number of variables
    fmpq_mpoly_ctx_t ctx;
    fmpq_mpoly_ctx_init(ctx, nv, ORD_DEGLEX);

    // Variable to hold the result
    fmpq_mpoly_t result;
    fmpq_mpoly_init(result, ctx);

    // Call the quasimodular_form function with Iq and weightmax
    quasimodular_form(result, Iq, weightmax, ctx);

    // Print the result in a pretty format
    std::cout << "Quasimodular form result: ";
    fmpq_mpoly_print_pretty(result, NULL, ctx);
    std::cout << std::endl;

    // Convert polynomial result to string
    std::string fey = fmpq_mpolyToString(result, ctx);
    std::cout << "Polynomial as string: " << fey << std::endl;

    answer=fey;

    // Clear polynomials and context
    fmpq_mpoly_clear(result, ctx);
    fmpq_mpoly_ctx_clear(ctx);

         ]]>
          </code>
        </module>
      </defun>
      <connect-in port="answer" place="fey_sum"/>
      <connect-in port="weightmax" place="genus"/>

      <connect-out port="answer" place="answer"/>
    </transition>
    <place name="answer" type="string" />

  </net>

</defun>