<defun name="feynman_deg">

  <in name="degree" type="int" place="degree"/>
  <in name="N" type="int" place="N"/>
  <in name="graph" type="list" place="graph"/>

  <out name="vectors" type="string" place="vectors"/>
  <out name="count" type="int" place="count"/>
  <out name="fey_sum" type="unsigned long" place="fey_sum"/>

  <out name="sum" type="unsigned long" place="sum"/>

  <net>
    <place name="degree" type="int"/>
    <place name="N" type="int"/>

    <transition name="initial">
      <defun>
        <in name="d" type="int"/>
        <in name="n" type="int"/>
        <out name="v" type="list"/>

        <module name="feynman_module" function=" gen_block (n,d,v)">
          <cinclude href="iostream"/>
          <cinclude href="vector"/>
          <cinclude href="sstream"/>
          <code><![CDATA[

            using pnet_value = pnet::type::value::value_type;
            using pnet_list = std::list<pnet_value>;
            std::vector<int> x(n, 0);
              x.front() = d ;
              pnet_list tmp;
              for (int xi : x)
              {
                tmp.push_back(pnet_value(xi));
              }
              v.push_back(tmp);

         ]]>
          </code>
        </module>
      </defun>
      <connect-in port="n" place="N"/>
      <connect-in port="d" place="degree"/>
      <connect-out-many port="v" place="init_vector"/>
    </transition>

    <place name="init_vector" type="list"/>
    <place name="vectors" type="string"/>
    <place name="state" type="string"/>

    <transition name="first_next_partition">
      <defun>
        <in name="v" type="list"/>
        <out name="vec" type="list"/>
        <out name="vec_copy" type="string"/>

        <module name="feynman_module" function=" iterat(v, vec,vec_copy)">
          <cinclude href="iostream"/>
          <cinclude href="vector"/>
          <cinclude href="numeric"/>
          <cinclude href="sstream"/>
          <cinclude href="feynman.hpp"/>

          <code><![CDATA[

          std::vector<int> x;
          for (const auto& elem : v) {
            auto ptr = boost::get<int>(&elem) ;
              x.push_back(*ptr);
            
          }
          int m=4;
          vector2d ru;
           ru.push_back(x);
      for (int ii=0; ii<m; ii++){
        x=next_partition(x);
          ru.push_back(x);
      }
   // vector2d gen = iterate(x);
    std::string    ve = vector2dToString(ru);
    //std::cout<<"first ve "<<ve<<" " <<std::endl;

    int nn=x.size();
    int d = std::accumulate(x.begin(), x.end(), 0);

    if(x[nn-1]!= d){
     vec_copy=vectorToStringInt(x) ;
    }
    using pnet_value = pnet::type::value::value_type;
    using pnet_list = std::list<pnet_value>;

    vec.push_back(ve);


          ]]>
          </code>
        </module>
      </defun>
      <connect-in port="v" place="init_vector"/>
      <connect-out-many port="vec" place="vectors"/>
      <connect-out port="vec_copy" place="state"/>

    </transition>

    <transition name="next_partitions">
      <defun>
        <in name="v" type="string"/>
        <out name="vec" type="list"/>
        <out name="vec_copy" type="string"/>
        <in name="size" type="int"/>

        <module name="feynman_module" function=" iterator(v, vec,vec_copy)">
          <cinclude href="iostream"/>
          <cinclude href="vector"/>
          <cinclude href="numeric"/>
          <cinclude href="sstream"/>
          <cinclude href="feynman.hpp"/>

          <code><![CDATA[
    std::vector<int> x=stringToVectorInt(v);
    int m=4;
    int nn=x.size();
    int d = std::accumulate(x.begin(), x.end(), 0);

    vector2d ru;
    for (int ii=0; ii<m; ii++){
      x=next_partition(x);
      ru.push_back(x);
      if(x[nn-1]== d){
     break ;
      }
    }
    std::string    ve = vector2dToString(ru);
    vec.push_back(ve);
//std::cout<<" ve "<<ve<<" " <<std::endl;
  
    if(x[nn-1]!= d){
     vec_copy=vectorToStringInt(x) ;
    }
    else {
    std::cout<<" bonjour"<<std::endl;
      vec_copy=std::string {"stop"};
    }
          ]]>
          </code>
        </module>
      </defun>
      <condition>
      ${v}:ne:"stop"
      </condition>
      <condition>
        ${size} :gt: 0
      </condition>
      <connect-in port="v" place="state"/>
      <connect-in port="size" place="size"/>
      <connect-out-many port="vec" place="vectors"/>
      <connect-out port="vec_copy" place="state"/>

    </transition>


    <place name="graph" type="list"/>
    <place name="fey_sum" type="unsigned long">
      <token>
        <value>0UL</value>
      </token>
    </place>
    <transition name="feynman_degree">
      <defun>
        <in name="a" type="string"/>
        <in name="G" type="list"/>
        <out name="size" type="int"/>
        <inout name="fey_sum" type="unsigned long"/>

        <out name="s" type="string"/>

        <module name="feynman_module" function="s feynman_integral_degree(fey_sum,G,a,size)">
          <cinclude href="iostream"/>
          <cinclude href="vector"/>
          <cinclude href="numeric"/>
          <cinclude href="tuple"/>
          <cinclude href="algorithm"/>
          <cinclude href="unordered_map"/>
          <cinclude href="functional"/>
          <cinclude href="cmath"/>
          <cinclude href="sstream"/>
          <cinclude href="stack"/>
          <cinclude href="unordered_set"/>
          <cinclude href="feynman.hpp"/>
          <code><![CDATA[
  std::cout<<"size "<< size<<std::endl;
          std::vector<int> xxx; // Define xxx outside the inner loop
    for (const auto &vii : G)
    {
        if (auto ptr = boost::get<int>(&vii))
        {                             // Check if the element is an integer
            xxx.push_back( *ptr ); // Push the integer to the vector xx
        }
    }
  std::vector<std::pair<int, int>> Gv;

    // Iterate over the vector of integers, creating pairs from consecutive elements
    for (size_t i = 0; i < xxx.size(); i += 2)
    {
        Gv.push_back(std::make_pair(xxx[i], xxx[i + 1]));
    }


// Read the vector of integers from the string
/* std::vector<int> av;
 for (const auto &xi : a)
        {
            if (auto ptr = boost::get<int>(&xi))
            {
                av.push_back( *ptr);
            }
        }
       */
    std::vector<int> fey;
    vector2d a_list= stringToVector2d(a) ;
    for (const auto &av : a_list){
      unsigned long fe=feynman_integral_branch_type(Gv, av);
    fey.push_back(fe);
    }
    unsigned long feysum = std::accumulate(fey.begin(), fey.end(), 0UL);
     fey_sum+=feysum;
    std::string feyn= vectorToStringInt(fey);
    std::cout<<" a "<<a<<std::endl;
    std::cout<<"feyn " <<feyn <<std::endl;
    return feyn;
      ]]>          </code>
        </module>
      </defun>

      <connect-read port="G" place="graph"/>
      <connect-in port="a" place="vectors"/>
      <connect-out port="size" place="size"/>
      <connect-inout port="fey_sum" place="fey_sum"/>

      <connect-out port="s" place="fey_out"/>
    </transition>

    <place name="fey_out" type="string" />
    <place name="size" type="int">
      <token>
        <value>3</value>
      </token>
    </place>
    <place name="count" type="int">
      <token>
        <value>0</value>
      </token>
    </place>

    <place name="sum" type="unsigned long">
      <token>
        <value>0UL</value>
      </token>
    </place>
    <transition name="Reduce">
      <defun>
        <in name="s" type="string"/>
        <out name="size" type="int"/>
        <inout name="sum" type="unsigned long"/>
        <inout name="count" type="int"/>

        <module name="feynman_module" function="plus (count,size,s, sum)">
          <cinclude href="iostream"/>
          <cinclude href="vector"/>
          <cinclude href="numeric"/>
          <cinclude href="feynman.hpp"/>

          <code><![CDATA[
            std::vector<int> se=stringToVectorInt(s);
         
            int d = std::accumulate(se.begin(), se.end(), 0);
             size=se.size();
             std::cout<<" se " <<s <<" " <<"size "<<se.size()<<std::endl;;
            std::cout<<" sum " <<sum <<"+ d " << d<<std::endl;
            count+=se.size();
            sum += d;
            std::cout<<"= sum " <<sum <<" "<<std::endl;

          ]]>          </code>
        </module>
      </defun>

      <connect-in port="s" place="fey_out"/>
      <connect-out port="size" place="size"/>
      <connect-inout port="sum" place="sum"/>
      <connect-inout port="count" place="count"/>

    </transition>
  </net>

</defun>