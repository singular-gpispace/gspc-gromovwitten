<defun name="feynman_deg">

  <in name="degree" type="int" place="degree"/>
  <in name="N" type="int" place="N"/>
  <in name="m" type="int" place="m"/>
  <in name="graph" type="list" place="graph"/>
  <in name="total" type="unsigned long" place="total"/>
  <out name="sum" type="unsigned long" place="sum"/>
  <out name="L" type="unsigned long" place="L"/>

  <net>
      <place name="total" type="unsigned long"/>

    <place name="degree" type="int"/>
    <place name="N" type="int"/>
    <place name="m" type="int"/>

    <transition name="transition1">
      <defun>
        <in name="d" type="int"/>
        <in name="n" type="int"/>
        <out name="v" type="list"/>

        <module name="feynman_module" function=" gen_block (n,d,v)">
          <cinclude href="iostream"/>
          <cinclude href="vector"/>
          <cinclude href="sstream"/>
          <code><![CDATA[

            using pnet_value = pnet::type::value::value_type;
            using pnet_list = std::list<pnet_value>;
            std::vector<int> x(n, 0);
              x.front() = d ;
              pnet_list tmp;
              for (int xi : x)
              {
                tmp.push_back(pnet_value(xi));
              }
              v.push_back(tmp);

         ]]>
          </code>
        </module>
      </defun>
      <connect-in port="n" place="N"/>
      <connect-in port="d" place="degree"/>
      <connect-out-many port="v" place="init_vector"/>
    </transition>

    <place name="init_vector" type="list"/>
    <place name="vectors" type="list"/>
    <place name="state" type="list"/>

    <transition name="transition2">
      <defun>
        <in name="v" type="list"/>
        <out name="vec" type="list"/>
        <out name="vec_copy" type="list"/>

        <module name="feynman_module" function=" iterat(v, vec,vec_copy)">
          <cinclude href="iostream"/>
          <cinclude href="vector"/>
          <cinclude href="numeric"/>
          <cinclude href="sstream"/>
          <cinclude href="feynman.hpp"/>

          <code><![CDATA[
  using pnet_value = pnet::type::value::value_type;
   using pnet_list = std::list<pnet_value>;
          std::vector<int> x;
          for (const auto& elem : v) {
            auto ptr = boost::get<int>(&elem) ;
              x.push_back(*ptr);
          }
  /***********************************************************
  ************************************************************/
    int nn=x.size();
    int d = std::accumulate(x.begin(), x.end(), 0);
      pnet_list tmp;
    if(x[nn-1]!= d){
              for (int xi : x)
              {
                tmp.push_back(pnet_value(xi));
              }
         vec_copy.push_back(tmp) ;
    }
  /***********************************************************
  ************************************************************/
   //std::string    ve = vectorToStringInt(x);

    vec.push_back(tmp) ;

   // vec.push_back(ve);

          ]]>
          </code>
        </module>
      </defun>
      <connect-in port="v" place="init_vector"/>
      <connect-out-many port="vec" place="vectors"/>
      <connect-out-many port="vec_copy" place="state"/>

    </transition>

    <transition name="transition3">
      <defun>
        <in name="m" type="int"/>
        <in name="v" type="list"/>

        <out name="vec" type="list"/>
        <out name="vec_copy" type="list"/>
        <in name="counter" type="int"/>
        <inout name="stop1" type="unsigned long"/>

        <module name="feynman_module" function=" iterator(stop1,m,counter,v, vec,vec_copy)">
          <cinclude href="iostream"/>
          <cinclude href="vector"/>
          <cinclude href="numeric"/>
          <cinclude href="sstream"/>
          <cinclude href="feynman.hpp"/>
          <code><![CDATA[
    using pnet_value = pnet::type::value::value_type;
    using pnet_list = std::list<pnet_value>;

    //std::vector<int> x=stringToVectorInt(v);
     std::vector<int> x;
          for (const auto& elem : v) {
            auto ptr = boost::get<int>(&elem) ;
              x.push_back(*ptr);
          }

    int nn=x.size();
    int d = std::accumulate(x.begin(), x.end(), 0);
    vector2d ru;
    for (int ii=0; ii<m; ii++){
       if(x[nn-1]== d){
          break ;
      }
      else{
        x=next_partition(x);
        stop1+=1;
        pnet_list tmpx;
        for (int xi : x)
        {
          tmpx.push_back(pnet_value(xi));
        }
        vec.push_back(tmpx);

        //std::string xx =vectorToStringInt(x);
        //vec.push_back(xx);
      }
    }
  /**************************************************************************
  ***************************************************************************/

    if(x[nn-1]!= d){
      pnet_list tmp;
      for (int xi : x)
      {
        tmp.push_back(pnet_value(xi));
      }
           vec_copy.push_back(tmp) ;
      //vec_copy=vectorToStringInt(x) ;
    }
   /* else {
      last_vector=std::string {"stop"};
    }
        <condition>
      ${last_vector}:ne:"stop"
      </condition>*/
          ]]>
          </code>
        </module>
      </defun>

      <condition>
        ${counter} :gt: 0
      </condition>
      <connect-read port="m" place="m"/>
      <connect-in port="counter" place="counter"/>
      <connect-out-many port="vec" place="vectors"/>
      <connect-out-many port="vec_copy" place="state"/>
      <connect-in port="v" place="state"/>
      <connect-inout port="stop1" place="stop1"/>

    </transition>


    <place name="graph" type="list"/>

    <transition name="transition4">
      <defun>
        <in name="branchs" type="list"/>
        <in name="G" type="list"/>

        <out name="s" type="unsigned long"/>

        <module name="feynman_module" function="s feynman_integral_degree(G,branchs)">
          <cinclude href="iostream"/>
          <cinclude href="vector"/>
          <cinclude href="numeric"/>

          <cinclude href="algorithm"/>
          <cinclude href="unordered_map"/>
          <cinclude href="functional"/>
          <cinclude href="cmath"/>
          <cinclude href="sstream"/>
          <cinclude href="stack"/>
          <cinclude href="unordered_set"/>
          <cinclude href="feynman.hpp"/>
          <code><![CDATA[

    std::vector<int> xxx; // Define xxx 
    for (const auto &vii : G)
    {
        if (auto ptr = boost::get<int>(&vii))
        {                             // Check if the element is an integer
            xxx.push_back( *ptr ); // Push the integer to the vector xxx
        }
    }
  std::vector<std::pair<int, int>> Gv;

    // Iterate over the vector of integers, creating pairs from consecutive elements
    for (size_t i = 0; i < xxx.size(); i += 2)
    {
        Gv.push_back(std::make_pair(xxx[i], xxx[i + 1]));
    }


// Read the vector of integers from the string
 std::vector<int> av;
 for (const auto &xi : branchs)
        {
            if (auto ptr = boost::get<int>(&xi))
            {
                av.push_back( *ptr);
            }
        }

     //std::vector<int> av= stringToVectorInt(branchs) ;
      unsigned long fe=feynman_integral_branch_type(Gv, av);

   
    return fe;
      ]]>
          </code>
        </module>
      </defun>

      <connect-read port="G" place="graph"/>
      <connect-in port="branchs" place="vectors"/>
      <connect-out port="s" place="fey_out"/>
    </transition>

    <place name="fey_out" type="unsigned long" />
    <place name="counter" type="int">
      <token>
        <value>3</value>
      </token>
    </place>

    <place name="limit" type="int">
      <token>
        <value>0</value>
      </token>
    </place>
    <place name="sum" type="unsigned long">
      <token>
        <value>0UL</value>
      </token>
    </place>
  
<transition name="RHS">
      <defun>
        <inout name="a" type="unsigned long"/>
        <inout name="s" type="control"/>
        <module name="token" function="plus()">
        <code><![CDATA[
        ]]></code>
        </module>
      </defun>
      <connect-in port="a" place="fey_out"/>
      <connect-in port="s" place="right_init"/>
      <connect-out port="s" place="left_init"/>
      <connect-out port="a" place="R"/>

    </transition>
<place name="left_init" type="control">
  <token><value>[]</value></token>
</place>
<place name="right_init" type="control"/>

    <transition name="LHS">
      <defun>
        <inout name="a" type="unsigned long"/>
        <inout name="s" type="control"/>

        <module name="token" function="count()">
        <code><![CDATA[

        ]]></code>
        </module>
      </defun>
      <connect-in port="s" place="left_init"/>
      <connect-out port="s" place="right_init"/>
      <connect-in port="a" place="fey_out"/>
      <connect-out port="a" place="L"/>
    </transition>


<place name="L" type="unsigned long"/>
<place name="R" type="unsigned long"/>

    <transition name="Reduce">
      <defun>
        <out name="counter" type="int"/>
        <inout name="limit" type="int"/>
        <in name="m" type="int"/>
        <out name="s" type="unsigned long"/>
        <in name="l" type="unsigned long"/>
        <in name="r" type="unsigned long"/>
        <inout name="stop" type="unsigned long"/>

        <module name="sum" function=" s add(stop,counter,limit,m,s,l,r)">
          <cinclude href="iostream"/>

        <code><![CDATA[
            limit+=1;
            stop+=1;
              std::cout<<"stop "<<stop<<std::endl;

            if(limit==m){
              limit=0;
               counter=m;
            }

            else{
              counter=0;
            }   
            
        unsigned long su = l + r;
        return su;
        ]]></code>
        </module>
      </defun>
      <connect-read port="m" place="m"/>
      <connect-out port="counter" place="counter"/>
      <connect-inout port="limit" place="limit"/>
      <connect-in port="l" place="L"/>
      <connect-in port="r" place="R"/>
      <connect-out port="s" place="fey_out"/>
      <connect-inout port="stop" place="stop"/>
    </transition>

 <place name="stop" type="unsigned long">
      <token>
        <value>1UL</value>
      </token>
  </place>
 <place name="stop1" type="unsigned long">
      <token>
        <value>1UL</value>
      </token>
  </place>
  
    <transition name="transition6">
      <defun>
        <in name="sum2_copy" type="unsigned long"/>
        <in name="total" type="unsigned long"/>
        <out name="sum_out" type="unsigned long"/>

        <module name="feynman_module" function="finish (total,sum_out,sum2_copy)">
          <cinclude href="iostream"/>
          <cinclude href="vector"/>
          <cinclude href="numeric"/>
          <cinclude href="feynman.hpp"/>
          <code><![CDATA[
                
          std::cout<<"sum2_copy "<<sum2_copy<<std::endl;

     /*  <condition>
        ${stop} :lt: ${total}
      </condition>
      */
          ]]>
          </code>
        </module>
      </defun>
      <connect-read port="total" place="total"/>
      <connect-out port="sum_out" place="sum2"/>

    </transition>
    <place name="sum2" type="unsigned long" />
  </net>

</defun>